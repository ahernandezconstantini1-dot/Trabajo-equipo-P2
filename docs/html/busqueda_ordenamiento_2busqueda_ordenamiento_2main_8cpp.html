<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="es">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Analisis de complejidad: Referencia del archivo src/busquedaOrdenamiento/busquedaOrdenamiento/main.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Analisis de complejidad<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Descripción breve del proyecto</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Buscar',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('busqueda_ordenamiento_2busqueda_ordenamiento_2main_8cpp.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Cargando...</div>
<div class="SRStatus" id="Searching">Buscando...</div>
<div class="SRStatus" id="NoMatches">Nada coincide</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Referencia del archivo main.cpp</div></div>
</div><!--header-->
<div class="contents">

<p>Programa principal unificado: demostración interactiva + benchmarks de algoritmos.  
<a href="#details">Más...</a></p>
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;chrono&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;random&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;iomanip&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;numeric&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &quot;<a class="el" href="search_8h_source.html">search.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sort_8h_source.html">sort.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="view_8h_source.html">view.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Gráfico de dependencias incluidas en main.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="busqueda_ordenamiento_2busqueda_ordenamiento_2main_8cpp__incl.png" border="0" usemap="#asrc_2busqueda_ordenamiento_2busqueda_ordenamiento_2main_8cpp" loading="lazy" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Clases</h2></td></tr>
<tr class="memitem:Stats" id="r_Stats"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="struct_stats.html">Stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estructura para almacenar estadísticas de rendimiento @complexity O(1) - Solo almacena 4 valores double.  <a href="struct_stats.html#details">Más...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
typedefs</h2></td></tr>
<tr class="memitem:accf829b29dcee7a09273bd9101f04e89" id="r_accf829b29dcee7a09273bd9101f04e89"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#accf829b29dcee7a09273bd9101f04e89">Clock</a> = std::chrono::high_resolution_clock</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Funciones</h2></td></tr>
<tr class="memitem:a75197b944da1ce9918225465616b536c" id="r_a75197b944da1ce9918225465616b536c"><td class="memItemLeft">static std::mt19937 &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a75197b944da1ce9918225465616b536c">rngGlobal</a> ()</td></tr>
<tr class="memdesc:a75197b944da1ce9918225465616b536c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generador de números aleatorios global (singleton).  <br /></td></tr>
<tr class="memitem:adb3800b82dbaf8777a1e8a284a6eba4b" id="r_adb3800b82dbaf8777a1e8a284a6eba4b"><td class="memItemLeft">std::vector&lt; int &gt;&#160;</td><td class="memItemRight"><a class="el" href="#adb3800b82dbaf8777a1e8a284a6eba4b">generarArreglo</a> (int n, int minVal=1, int maxVal=100000)</td></tr>
<tr class="memdesc:adb3800b82dbaf8777a1e8a284a6eba4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Genera un arreglo de enteros aleatorios.  <br /></td></tr>
<tr class="memitem:abe3b66d3dd91587f63cb2e9e475e895b" id="r_abe3b66d3dd91587f63cb2e9e475e895b"><td class="memItemLeft">double&#160;</td><td class="memItemRight"><a class="el" href="#abe3b66d3dd91587f63cb2e9e475e895b">medirUnaCorridaMs</a> (const std::function&lt; void()&gt; &amp;fn)</td></tr>
<tr class="memdesc:abe3b66d3dd91587f63cb2e9e475e895b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mide el tiempo de una única ejecución de función.  <br /></td></tr>
<tr class="memitem:acaf0049fb1859d2a3bca1ea0737271cd" id="r_acaf0049fb1859d2a3bca1ea0737271cd"><td class="memItemLeft"><a class="el" href="struct_stats.html">Stats</a>&#160;</td><td class="memItemRight"><a class="el" href="#acaf0049fb1859d2a3bca1ea0737271cd">medirVariasCorridasMs</a> (const std::function&lt; void()&gt; &amp;fn, int repeticiones, int warmup=1)</td></tr>
<tr class="memdesc:acaf0049fb1859d2a3bca1ea0737271cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mide estadísticas de rendimiento sobre múltiples ejecuciones.  <br /></td></tr>
<tr class="memitem:acb2e736b0e4652e3b1a0a127d28982d6" id="r_acb2e736b0e4652e3b1a0a127d28982d6"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#acb2e736b0e4652e3b1a0a127d28982d6">ejecutarBenchmarks</a> ()</td></tr>
<tr class="memdesc:acb2e736b0e4652e3b1a0a127d28982d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ejecuta benchmarks automáticos y exporta resultados a CSV.  <br /></td></tr>
<tr class="memitem:ac4d46cb53f391570740c6e00ea8590c4" id="r_ac4d46cb53f391570740c6e00ea8590c4"><td class="memItemLeft">std::vector&lt; int &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ac4d46cb53f391570740c6e00ea8590c4">generarArregloInteractivo</a> (int &amp;outN)</td></tr>
<tr class="memdesc:ac4d46cb53f391570740c6e00ea8590c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Menú interactivo para generar arreglos con diferentes configuraciones.  <br /></td></tr>
<tr class="memitem:ae66f6b31b5ad750f1fe042a706a4e3d4" id="r_ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memItemLeft">int&#160;</td><td class="memItemRight"><a class="el" href="#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</td></tr>
<tr class="memdesc:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Punto de entrada principal del programa.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Descripción detallada</h2>
<div class="textblock"><p>Programa principal unificado: demostración interactiva + benchmarks de algoritmos. </p>
<dl class="section author"><dt>Autor</dt><dd>Equipo de Desarrollo </dd></dl>
<dl class="section date"><dt>Fecha</dt><dd>2024</dd></dl>
<h1 class="doxsection"><a class="anchor" id="complejidad"></a>
COMPLEJIDAD GLOBAL DEL PROGRAMA</h1>
<h2 class="doxsection"><a class="anchor" id="tiempo"></a>
COMPLEJIDAD TEMPORAL</h2>
<ul>
<li><b>Peor caso:</b> O(k × n²) cuando el usuario selecciona repetidamente métodos de ordenamiento cuadráticos (Burbuja, Selección, Inserción)</li>
<li><b>Caso promedio:</b> O(k × n log n) utilizando QuickSort o MergeSort</li>
<li><b>Mejor caso:</b> O(k × n) con búsquedas secuenciales sin ordenamiento</li>
<li>Donde k = número de operaciones del usuario (iteraciones del menú)</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="espacio"></a>
COMPLEJIDAD ESPACIAL</h2>
<ul>
<li><b>Arreglo de datos:</b> O(n) donde n es el tamaño del arreglo</li>
<li><b>Stack de recursión (QuickSort):</b> O(log n) promedio, O(n) peor caso</li>
<li><b>Stack de recursión (MergeSort):</b> O(log n)</li>
<li><b>Vector temporal (MergeSort):</b> O(n)</li>
<li><b>Total auxiliar:</b> O(n) en el peor caso (MergeSort) </li>
</ul>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Documentación de «typedef»</h2>
<a id="accf829b29dcee7a09273bd9101f04e89" name="accf829b29dcee7a09273bd9101f04e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf829b29dcee7a09273bd9101f04e89">&#9670;&#160;</a></span>Clock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#accf829b29dcee7a09273bd9101f04e89">Clock</a> = std::chrono::high_resolution_clock</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Documentación de funciones</h2>
<a id="acb2e736b0e4652e3b1a0a127d28982d6" name="acb2e736b0e4652e3b1a0a127d28982d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2e736b0e4652e3b1a0a127d28982d6">&#9670;&#160;</a></span>ejecutarBenchmarks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ejecutarBenchmarks </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ejecuta benchmarks automáticos y exporta resultados a CSV. </p>
<p>@complexity Variable según los tamaños de prueba:</p><ul>
<li>Para cada tamaño n: O(n²) métodos cuadráticos, O(n log n) eficientes</li>
<li>Total: O(Σ(n² + n log n)) para todos los tamaños de prueba</li>
</ul>
<p>@spacecomplexity O(n) - Crea copias temporales del arreglo para cada prueba</p>
<p>Ejecuta todos los algoritmos con tamaños predefinidos (1000, 5000, 10000) y exporta estadísticas detalladas a resultados.csv </p>
<p>@complexity O(n²) - Burbuja cuadrático</p>
<p>@complexity O(n²) - Selección cuadrático</p>
<p>@complexity O(n²) peor, O(n) mejor - Inserción adaptable</p>
<p>@complexity O(n log n) promedio, O(n²) peor - QuickSort</p>
<p>@complexity O(n log n) garantizado - MergeSort</p>

</div>
</div>
<a id="adb3800b82dbaf8777a1e8a284a6eba4b" name="adb3800b82dbaf8777a1e8a284a6eba4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3800b82dbaf8777a1e8a284a6eba4b">&#9670;&#160;</a></span>generarArreglo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; generarArreglo </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>minVal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxVal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">100000</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Genera un arreglo de enteros aleatorios. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Tamaño del arreglo </td></tr>
    <tr><td class="paramname">minVal</td><td>Valor mínimo (default: 1) </td></tr>
    <tr><td class="paramname">maxVal</td><td>Valor máximo (default: 100000) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>std::vector&lt;int&gt; Vector con valores aleatorios</dd></dl>
<p>@complexity O(n) - Genera n números aleatorios secuencialmente @spacecomplexity O(n) - Almacena n enteros en el vector </p>

</div>
</div>
<a id="ac4d46cb53f391570740c6e00ea8590c4" name="ac4d46cb53f391570740c6e00ea8590c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d46cb53f391570740c6e00ea8590c4">&#9670;&#160;</a></span>generarArregloInteractivo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; generarArregloInteractivo </td>
          <td>(</td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>outN</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Menú interactivo para generar arreglos con diferentes configuraciones. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">outN</td><td>Parámetro de salida con el tamaño final del arreglo </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>std::vector&lt;int&gt; Arreglo generado según especificaciones del usuario</dd></dl>
<p>@complexity O(n) o O(rango) según el modo seleccionado @spacecomplexity O(n) - Retorna vector del tamaño solicitado </p>

</div>
</div>
<a id="ae66f6b31b5ad750f1fe042a706a4e3d4" name="ae66f6b31b5ad750f1fe042a706a4e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f6b31b5ad750f1fe042a706a4e3d4">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Punto de entrada principal del programa. </p>
<dl class="section return"><dt>Devuelve</dt><dd>int Código de salida (0 = éxito)</dd></dl>
<p>@complexity </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Aspecto  </th><th class="markdownTableHeadNone">Complejidad  </th><th class="markdownTableHeadNone">Descripción  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Tiempo (peor)  </td><td class="markdownTableBodyNone">O(k × n²)  </td><td class="markdownTableBodyNone">k iteraciones con ordenamiento O(n²)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Tiempo (prom)  </td><td class="markdownTableBodyNone">O(k × n log n)  </td><td class="markdownTableBodyNone">k iteraciones con ordenamiento óptimo  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Tiempo (mejor)  </td><td class="markdownTableBodyNone">O(k × n)  </td><td class="markdownTableBodyNone">Solo búsquedas secuenciales  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Espacio  </td><td class="markdownTableBodyNone">O(n)  </td><td class="markdownTableBodyNone">Arreglo dinámico + overhead de recursión  </td></tr>
</table>
<dl class="section note"><dt>Nota</dt><dd>El programa opera en un bucle interactivo donde k representa la cantidad de operaciones que el usuario realiza antes de salir. </dd></dl>
<p>Arreglo dinámico para soportar tamaños N, N*N, N*M</p>
<p>Flag para activar/desactivar modo verbose (paso a paso)</p>
<p>Variables para métricas de QuickSort y MergeSort</p>
<p>Inicialización: Generación del arreglo aleatorio @complexity O(n) donde n depende de la opción seleccionada (N, N², N×M) @spacecomplexity O(n) para almacenar el vector generado</p>
<p>@case CASE_0_REGENERAR Regenera el arreglo con nuevos parámetros</p>
<p>@complexity</p><ul>
<li><b>Temporal:</b> O(n) para generar el nuevo arreglo</li>
<li><b>Espacial:</b> O(n) para el nuevo vector (el anterior se libera)</li>
</ul>
<p>Permite al usuario especificar:</p><ul>
<li>Tamaño: N, N×N, o N×M</li>
<li>Modo: Con repetidos (uniforme) o sin repetidos (shuffle)</li>
<li>Rango: Valores mínimos y máximos</li>
</ul>
<p>@case CASE_1_BUSQUEDA_SECUENCIAL Realiza búsqueda lineal en el arreglo</p>
<p>@complexity </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operación  </th><th class="markdownTableHeadNone">Complejidad  </th><th class="markdownTableHeadNone">Notación Big-O  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="view_8cpp.html#afd6df2510401f6e3589246083fb2b474">mostrarArreglo()</a>  </td><td class="markdownTableBodyNone">Lineal  </td><td class="markdownTableBodyNone">O(n)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="view_8cpp.html#af04796db10787812a2067e24fa59a968">pedirValor()</a>  </td><td class="markdownTableBodyNone">Constante  </td><td class="markdownTableBodyNone">O(1)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="search_8cpp.html#aadbd873404a46c967cb5d75246de6d4f">busquedaSecuencial()</a>  </td><td class="markdownTableBodyNone">Lineal  </td><td class="markdownTableBodyNone"><b>O(n)</b>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Impresión resultado  </td><td class="markdownTableBodyNone">Constante  </td><td class="markdownTableBodyNone">O(1)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>TOTAL</b>  </td><td class="markdownTableBodyNone"><b>Lineal</b>  </td><td class="markdownTableBodyNone"><b>O(n)</b>  </td></tr>
</table>
<p>@complexity_detailed</p><ul>
<li><b>Peor caso:</b> O(n) - elemento no existe o está al final</li>
<li><b>Mejor caso:</b> O(1) - elemento en primera posición</li>
<li><b>Caso promedio:</b> O(n/2) = O(n) - asumiendo distribución uniforme</li>
</ul>
<p>@spacecomplexity O(1) - Solo usa índices auxiliares</p>
<dl class="section pre"><dt>Precondición</dt><dd>El arreglo puede estar en cualquier estado (no requiere orden) </dd></dl>
<dl class="section post"><dt>Postcondición</dt><dd>Posición del elemento encontrado o -1 si no existe</dd></dl>
<dl class="section invariant"><dt>Invariante</dt><dd>Se mantiene: 0 ≤ índice &lt; n durante la búsqueda</dd></dl>
<p>@case CASE_2_BUSQUEDA_BINARIA Ordena con Burbuja y realiza búsqueda binaria</p>
<p>@complexity </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operación  </th><th class="markdownTableHeadNone">Complejidad  </th><th class="markdownTableHeadNone">Detalle Matemático  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="_sort_8cpp.html#a983da0b62266b09069a21cc3df36c000">ordenarBurbuja()</a>  </td><td class="markdownTableBodyNone">Cuadrática  </td><td class="markdownTableBodyNone"><b>O(n²)</b> - Σ(i=1 to n-1) i = n(n-1)/2  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="view_8cpp.html#afd6df2510401f6e3589246083fb2b474">mostrarArreglo()</a>  </td><td class="markdownTableBodyNone">Lineal  </td><td class="markdownTableBodyNone">O(n)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="view_8cpp.html#af04796db10787812a2067e24fa59a968">pedirValor()</a>  </td><td class="markdownTableBodyNone">Constante  </td><td class="markdownTableBodyNone">O(1)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="search_8cpp.html#a28d7202b1ed433915529bf064c2a5f52">busquedaBinaria()</a>  </td><td class="markdownTableBodyNone">Logarítmica  </td><td class="markdownTableBodyNone"><b>O(log n)</b> - ⌊log₂(n)⌋+1 iteraciones  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>TOTAL</b>  </td><td class="markdownTableBodyNone"><b>Cuadrática</b>  </td><td class="markdownTableBodyNone"><b>O(n²)</b> ← Dominada por Burbuja  </td></tr>
</table>
<p>@complexity_detailed <b>Análisis de <a class="el" href="_sort_8cpp.html#a983da0b62266b09069a21cc3df36c000">ordenarBurbuja()</a>:</b></p><ul>
<li>Comparaciones: n(n-1)/2 = Θ(n²) (siempre, sin optimización de bandera)</li>
<li>Intercambios: 0 a n(n-1)/2 dependiendo del desorden inicial</li>
<li>Pasadas: n-1 garantizadas</li>
</ul>
<p><b>Análisis de <a class="el" href="search_8cpp.html#a28d7202b1ed433915529bf064c2a5f52">busquedaBinaria()</a>:</b></p><ul>
<li>Iteraciones máximas: ⌊log₂(n)⌋ + 1</li>
<li>Ejemplos: n=1,000→10, n=1,000,000→20, n=10⁹→30 iteraciones</li>
</ul>
<p>@spacecomplexity O(1) - Ordenamiento in-place, búsqueda con índices</p>
<dl class="section pre"><dt>Precondición</dt><dd>El arreglo puede estar desordenado (se ordena internamente) </dd></dl>
<dl class="section post"><dt>Postcondición</dt><dd>Arreglo ordenado ascendentemente + posición del valor buscado</dd></dl>
<dl class="section warning"><dt>Atención</dt><dd>El cuello de botella es <a class="el" href="_sort_8cpp.html#a983da0b62266b09069a21cc3df36c000">ordenarBurbuja()</a> con O(n²). Para n &gt; 10,000, considerar usar Case 3 con QuickSort/MergeSort y luego <a class="el" href="search_8cpp.html#a28d7202b1ed433915529bf064c2a5f52">busquedaBinaria()</a> manualmente.</dd></dl>
<p>@invariant_post_ordenamiento Para todo i, 0 ≤ i &lt; n-1: A[i] ≤ A[i+1]</p>
<p>@case CASE_3_MENU_ORDENAMIENTO Menú de selección de algoritmos de ordenamiento</p>
<p>@complexity Variable según método seleccionado:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Método  </th><th class="markdownTableHeadNone">#  </th><th class="markdownTableHeadNone">Temporal  </th><th class="markdownTableHeadNone">Espacial  </th><th class="markdownTableHeadNone">Estable  </th><th class="markdownTableHeadNone">In-place  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Burbuja  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone"><b>O(n²)</b>  </td><td class="markdownTableBodyNone">O(1)  </td><td class="markdownTableBodyNone">Sí  </td><td class="markdownTableBodyNone">Sí  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Selección  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone"><b>O(n²)</b>  </td><td class="markdownTableBodyNone">O(1)  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">Sí  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Inserción  </td><td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">O(n²) peor, <b>O(n)</b> mejor  </td><td class="markdownTableBodyNone">O(1)  </td><td class="markdownTableBodyNone">Sí  </td><td class="markdownTableBodyNone">Sí  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">QuickSort  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone"><b>O(n log n)</b> avg, O(n²) peor  </td><td class="markdownTableBodyNone">O(log n) avg  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">Sí  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MergeSort  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone"><b>O(n log n)</b> garantizado  </td><td class="markdownTableBodyNone">O(n)  </td><td class="markdownTableBodyNone">Sí  </td><td class="markdownTableBodyNone">No  </td></tr>
</table>
<p>@complexity_detailed</p>
<p><b>Método 1 - Burbuja (Bubble Sort):</b></p><ul>
<li>Fórmula: T(n) = n(n-1)/2 comparaciones + swaps</li>
<li>Siempre Θ(n²) - no detecta arreglo ordenado</li>
</ul>
<p><b>Método 2 - Selección (Selection Sort):</b></p><ul>
<li>Comparaciones: SIEMPRE n(n-1)/2 (no tiene mejor caso)</li>
<li>Intercambios: EXACTAMENTE n-1 (mínimo posible)</li>
<li>Útil cuando los swaps son costosos (ej: escritura en disco)</li>
</ul>
<p><b>Método 3 - Inserción (Insertion Sort):</b></p><ul>
<li>Peor caso (inverso): n(n-1)/2 comparaciones y movimientos</li>
<li>Mejor caso (ordenado): n-1 comparaciones, 0 movimientos</li>
<li>Excelente para datos "casi ordenados" (desplazamiento pequeño)</li>
</ul>
<p><b>Método 4 - QuickSort:</b></p><ul>
<li>Recurrencia promedio: T(n) = 2T(n/2) + O(n) → O(n log n)</li>
<li>Recurrencia peor caso: T(n) = T(n-1) + O(n) → O(n²)</li>
<li>Peor caso ocurre con: arreglo ordenado + pivote central fijo</li>
<li>Espacio de pila: O(log n) promedio, O(n) peor caso recursivo</li>
</ul>
<p><b>Método 5 - MergeSort:</b></p><ul>
<li>Recurrencia: T(n) = 2T(n/2) + O(n) → Θ(n log n) (Teorema Maestro, caso 2)</li>
<li>Árbol de recursión: log₂(n) niveles × n trabajo por nivel</li>
<li>Espacio adicional: O(n) para vector temporal en merge</li>
<li>Único método que garantiza O(n log n) sin depender de entrada</li>
</ul>
<p>@spacecomplexity</p><ul>
<li>Métodos 1-4: O(1) auxiliar (in-place)</li>
<li>Método 5: O(n) auxiliar (vector temporal)</li>
<li>Stack recursión (4-5): O(log n) típico</li>
</ul>
<dl class="section pre"><dt>Precondición</dt><dd>El arreglo puede estar en cualquier estado </dd></dl>
<dl class="section post"><dt>Postcondición</dt><dd>Arreglo ordenado ascendentemente según el método elegido</dd></dl>
<p>@recommendations</p><ul>
<li><b>n &lt; 50:</b> Cualquier método (simpleza &gt; eficiencia)</li>
<li><b>n &lt; 1000, casi ordenado:</b> Inserción (O(n) efectivo)</li>
<li><b>n grande, memoria limitada:</b> QuickSort (más rápido promedio)</li>
<li><b>n grande, necesita estabilidad:</b> MergeSort (garantizado O(n log n))</li>
<li><b>Evitar:</b> Burbuja para cualquier n &gt; 100 (puramente educativo)</li>
</ul>
<dl class="section invariant"><dt>Invariante</dt><dd>Todos los métodos garantizan: ∀i ∈ [0, n-2]: arreglo[i] ≤ arreglo[i+1]</dd></dl>
<p>@complexity O(n²) - Burbuja siempre cuadrático</p>
<p>@complexity O(n²) - Selección siempre cuadrático</p>
<p>@complexity O(n²) peor, O(n) mejor - Inserción adaptable</p>
<p>@complexity O(n log n) promedio, O(n²) peor - QuickSort @spacecomplexity O(log n) pila de recursión promedio</p>
<p>@complexity O(n log n) garantizado - MergeSort @spacecomplexity O(n) vector temporal + O(log n) pila</p>
<p>@complexity O(1) - Manejo de entrada inválida</p>
<p>@case CASE_4_BENCHMARKS Ejecuta benchmarks automáticos y exporta a CSV</p>
<p>@complexity Variable: O(Σ(n² + n log n)) para todos los tamaños de prueba @spacecomplexity O(n) - Crea copias temporales para cada prueba</p>
<p>Ejecuta todos los algoritmos con tamaños predefinidos (1000, 5000, 10000) y genera resultados.csv con estadísticas.</p>
<p>@case CASE_5_SALIR Termina la ejecución del programa</p>
<p>@complexity O(1) - Operación de salida constante @spacecomplexity O(1) - Liberación automática de recursos (vector)</p>
<p>@case DEFAULT_OPCION_INVALIDA Manejo de opción de menú no reconocida</p>
<p>@complexity O(1) - Impresión de error constante</p>
<p>Liberación de recursos @complexity O(1) - El vector se destruye automáticamente al salir del scope @spacecomplexity O(1) - Liberación de memoria dinámica del vector</p>

</div>
</div>
<a id="abe3b66d3dd91587f63cb2e9e475e895b" name="abe3b66d3dd91587f63cb2e9e475e895b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3b66d3dd91587f63cb2e9e475e895b">&#9670;&#160;</a></span>medirUnaCorridaMs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double medirUnaCorridaMs </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mide el tiempo de una única ejecución de función. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>Función a medir (lambda o std::function) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>double Tiempo en milisegundos</dd></dl>
<p>@complexity O(1) respecto a la medición, O(T(fn)) respecto a la función medida </p>

</div>
</div>
<a id="acaf0049fb1859d2a3bca1ea0737271cd" name="acaf0049fb1859d2a3bca1ea0737271cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf0049fb1859d2a3bca1ea0737271cd">&#9670;&#160;</a></span>medirVariasCorridasMs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_stats.html">Stats</a> medirVariasCorridasMs </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>repeticiones</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>warmup</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mide estadísticas de rendimiento sobre múltiples ejecuciones. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>Función a benchmarkear </td></tr>
    <tr><td class="paramname">repeticiones</td><td>Número de repeticiones para estadísticas </td></tr>
    <tr><td class="paramname">warmup</td><td>Repeticiones de calentamiento (default: 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd><a class="el" href="struct_stats.html" title="Estructura para almacenar estadísticas de rendimiento @complexity O(1) - Solo almacena 4 valores doub...">Stats</a> Estadísticas calculadas</dd></dl>
<p>@complexity O(repeticiones × T(fn)) - Ejecuta fn múltiples veces @spacecomplexity O(repeticiones) - Almacena tiempos en vector temporal </p>

</div>
</div>
<a id="a75197b944da1ce9918225465616b536c" name="a75197b944da1ce9918225465616b536c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75197b944da1ce9918225465616b536c">&#9670;&#160;</a></span>rngGlobal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mt19937 &amp; rngGlobal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generador de números aleatorios global (singleton). </p>
<dl class="section return"><dt>Devuelve</dt><dd>std::mt19937&amp; Referencia al generador inicializado @complexity O(1) - Inicialización lazy una sola vez </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a href="dir_5455bac3f60d7d0410542b89258eddf7.html">busquedaOrdenamiento</a></li><li class="navelem"><a href="dir_7f5c2961d06812601e7a5882e392f1ff.html">busquedaOrdenamiento</a></li><li class="navelem"><a href="busqueda_ordenamiento_2busqueda_ordenamiento_2main_8cpp.html">main.cpp</a></li>
    <li class="footer">Generado por <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
